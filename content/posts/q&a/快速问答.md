+++
title = '快速问答.md'
date = 2023-11-09T15:56:46+08:00
draft = true
+++

## 怎么保证消息顺序

使用消息队列，并对消息的收发者使用 hash 分配消息的收发队列，同一个发送者或者接受者只从同一个队列收发消息

## 如果客户端接受服务器返回的消息失败，无限尝试重发消息，怎么处理

在服务器存储一个针对当前客户端的唯一消息 id，客户端初次连接返回给客户端，每次客户端向服务器发送消息都要带上这个唯一 id，每次服务器接到客户端消息后都要更新这个唯一 id 并返回给客户端

## 大量数据取前N个

分配一个大小位N的数组，然后数据以此对比插入这个数组，比数组中的数据小则插入数组，数组满了则抛弃最后一个

## 设计模式

*   单例
*   观察者

    *   缺点

        *
*   代理
*   适配器
*   策略

## 零拷贝

传统 io 操作需要把数据从硬盘读取后写入 cpu 缓存，再从 cpu 缓存复制到用户缓存

然后再从用户缓存写入 socket 缓存，socket 缓存还需要写入网络来发送出去

这中间需要内核态和用户态之间的多次切换和数据的多次拷贝

零拷贝就是避免数据拷贝到用户缓存，靠底层 mmap、sendfile 等实现

### mmap是怎么回事

内存映射：将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。

### sendfile是怎么回事

主要用于网络传输中，在内核环境中操作在两个文件描述符中直接传递数据

## 为什么要用集群

*   高性能（多主机算力高）
*   性价比（比一整台主机要省钱）
*   可伸缩
*   高可用（不会整体瘫痪）

## 分布式和微服务

分布式就是将程序和数据通过网络分布在多台计算机上来完成更复杂的任务。

微服务是指将一个程序拆分成多个服务，每个服务只负责完成单一的任务。

## 集群是分布式吗

集群是每台计算机都做相同的任务，只不过可能数据不同

分布式的每台计算机做的不一定是相同的任务

## ioc 控制反转

表示把原本需要程序员自己写的创建对象和给对象赋值的操作交给 spring 来控制，叫做控制反转

## 接触过战斗吗

接触过一些技能方面的改动

## 技能怎么做的

技能由一些效果组成，典型的比如伤害、沉默、定身等等
具体效果需要编写具体的代码
比如

### TCP/IP（传输控制协议/网际协议）

TCP 用于应用程序之间的通信，IP 用于计算机之间的通信，TCP/IP 意味着两者协同工作。TCP 负责分割和组合数据包，IP 负责将包发送至接受者。

## 项目相关

### 视野优化

同屏最大人数走配置
逐步添加玩家，避免同时消息过多（分次发送）

## 实时大数据玩家排行榜实现

最基本的数据结构：id(long) + score(int)
内存估计

## 支付流程

## 数据结构

链表
树
跳跃表
平衡二叉树

### 动态查找树

*   二叉查找树（Binary Search Tree）
*   平衡二叉查找树（Balance Binary Search Tree）
*   红黑树（Red-Black Tree）
*   B 树（Balance Tree），全称为平衡多路查找树，B- 树就是B 树，- 不是减的意思
*   B+ 树
*   B\* 树

> 前三个是典型的二叉查找树结构，后面的则是多叉查找树结构
> 二叉结构在元素数量非常多的情况下，树的深度会非常大，查找会退化成节点内部的线性结构，效率低下
> 想要减少树的深度，那么一个基本的做法就是采用多叉树结构

#### B 树

B 树的定义中，会用到一个叫阶或者度的名词 Degree
一颗 m 阶的 B 树的特性如下：

1.  若根节点不是叶子节点，则至少有 2 个孩子（也就是说不存在根节点上只有一个孩子的情况出现，这时这个孩子也应该是跟节点上的一个值，即跟节点上有两个关键字） 个孩子（m >= 2）
2.  除根节点和叶子节点外，其他每个中间节点至少有 k 个孩子和 k-1 个关键字，其中 m/2 <= k <= m
3.  每个叶子节点都包含 k-1 个元素，其中 m/2 <= k <= m
4.  所有叶子节点都出现在同一层，叶子节点不包含任何关键字信息
5.  每个节点上的关键字按增序排列

#### B+ 树

B+ 树是由 B 树进化而来的，与 B 树的主要区别有：

1.  B 树内部节点是会保存数据，而 B+ 树的内部节点不保存数据，值做索引作用，只有叶子节点保存数据
2.  B+ 树的相邻叶子节点之间通过链表指针链接起来，而 B 树没有
3.  查找过程中，B 树在找到具体数值后就结束，而 B+ 树则需要一直找到叶子节点才行
4.  B 树中的任何一个关键字都只会出现在一个节点中，而 B+ 树中的关键字是冗余的

mysql 中的 B+ 树还建立了双向指针

## 锁相关

### CAS 机制

CAS - Compare And Swap，比较并替换
三个操作数：内存值V、旧的预期值 A，要修改的值 B
当且仅当预期值 A 和内存指 V相等时，才将内存值修改为 B 并返回 true，否则说明已经被其他线程更改，返回 false。
使用场景：RentrantLock、Atomic 操作

## TCP/IP 流量控制 阻塞控制

慢开始算法：开一半窗口，但是每传输成功一次，窗口就加一倍，直到大于慢开始门限
拥塞避免算法：窗口大于慢开始门限后转用拥塞避免，窗口每次加一，一旦网络发生阻塞，则窗口折半重新使用慢开始

快重传：网络未阻塞，个别报文丢失
快恢复：接收方压力小，发送三个连续的确认到发送方，发送方将慢开始门限减半，然后启用拥塞避免

可靠传输机制
停止等待：发送完数据等待接收方确认，确认没错后再继续发送
回退N帧：数据发生错误，则接收方抛弃这组数据，然后重复发送N次确认信息到发送方，发送方就知道是之前N个数据发生了错误，然后重传这些数据
选择重传：再回退N帧的基础上不回退，而是收集所有错误数据，等所有有错的数据重新准备后一起重新传送

握手

*   客户端发送同步消息，然后进入同步已发送状态&#x20;
*   服务器收到同步消息，进入同步已接收状态，然后向客户端发送确认消息
*   客户端收到确认消息，再次向服务器发送客户端的确认消息，然后两者进入连接已建立状态

挥手

*   客户端发送结束消息，然后进入停止等待状态1
*   服务器收到结束消息，进入关闭等待状态，然后向客户端发送确认消息
*   客户端收到确认消息，进入停止等待状态2
*   服务器继续将未发送完的消息发送给客户端，发送完之后发送最后停止消息，进入最终确认状态
*   客户端收到结束消息，发送确认结束消息到服务器，进入超时等待状态
*   服务器收到确认结束消息后，关闭连接，如果没有收到确认结束消息，客户端会再超时等待的时间过了之后重新发送确认结束消息

