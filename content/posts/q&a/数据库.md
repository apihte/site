+++
title = 'MySQL.md'
date = 2023-11-09T15:56:46+08:00
draft = true
+++

# MySQL

## 语法

> 去重

```sql
select distinct colname from table;
```

## 事务

### 特性

1. **原子性**，事务中的操作是不可分割的，要么同时成功，要么同时失败

2. **一致性**，一个事务必须是数据库从一个一致性状态变换到另一个一致性状态，一致性是最终目的，其他三个特性都是为了保证一致性服务

3. **隔离性**，一个事务内的操作和数据与其他事务时隔离的，并发执行的各个事物之间不能互相干扰。

   为了解决的问题：

   1. **脏读**，事务 A 修改了一个数据但未提交，事务 B 读取到了事务 A 未提交的数据，如果事务 A 失败了，事务 B 读取到的就是脏数据。
   2. **不可重复读**，同一个事务中，对于同一份数据读取到的结果不一致，原因是并发事务修改记录。比如事务 B 分别读取了事务 A 提交前和提交后的数据，两份数据的结果可能是不同的，解决这种方法最简单的就是加锁，单会导致锁竞争，影响性能。
   3. **幻读**，同一个事务中，同一个查询多次返回的结果不一致。比如事务 A 增加了一条记录，事务 B 在事务 A 提交前后各执行了一次查询，发现后一次比前一次多了一条记录。幻读是指由于并发事务增加记录导致的问题，需要将事务串行化才能避免幻读。

   隔离级别：

   1. **未提交读**，允许读取未提交数据，最低一致性级别，对任何情况都不做保证。
   2. **已提交读**，只允许读取已提交数据，但不要求可重复读，避免脏读。
   3. **可重复读**，只允许读取已提交数据，而且一个事务两次读取一个数据项期间，其他事务不得更新该数据，避免脏读、不可重复读。
   4. **可串行化**，通常保证可串行化调度，最高隔离性级别，避免脏读、不可重复度、幻读。

   以上所有隔离性级别都不允许脏写，一个数据已经被另一个尚未提交或中止的事务写入，则不允许对该数据执行写操作，许多数据库的默认隔离性级别是已提交读。

4. **持久性**，事务提交后数据就会持久化地写入数据库，并不会被回滚。

## 索引

### 索引分类

### 数据结构

B+ 树

### 创建索引

create index xxx on table();

## InnoDB 和 MyISAM

|          | MyISAM                   | InnoDB                                           |
| -------- | ------------------------ | ------------------------------------------------ |
| 行锁     | 不支持                   | 支持                                             |
| 外键     | 不支持                   | 支持                                             |
| 全文索引 | 支持                     | 不支持，5.6.10 后支持                            |
| 事务     | 不支持                   | 支持                                             |
| 物理占用 | 较小                     | 较大，约为 MyISAM 的 2 倍                        |
| 物理文件 | 表名命名的 frm、MYD、MYI | 表名命名的 frm 和 idb，上级目录下的 ibdata1 文件 |

> frm: - 表结构定义文件
>
> MYD - MyISAM 表数据存储文件
>
> MYI - MyISAM 表索引存储文件
>
> ibdata1 - innoDB 共享表空间数据存储文件
>
> ibtmp1 - innoDB 临时表空间文件
>
> ibd - innoDB 独立表空间表数据备份文件
>
> db.opt - 记录默认字符集编码和字符集排序规则设置

## 缓存淘汰机制

### FIFO（先进先出）

最先加入到缓存的最先被淘汰

### LRU（最久未被使用）

最新缓存添加到队首，最近被使用的缓存被移动至队首，队列满时，移除队尾缓存

### LFU（使用频率最少）

最新缓存添加到队尾，被使用的缓存和前一个缓存对比进行排序，定期移除队尾的缓存
